<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>Abstruse Dashboard v2</title>

<!-- Leaflet for Radar -->
<link
  rel="stylesheet"
  href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
  integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
  crossorigin=""
/>
<script
  src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
  integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
  crossorigin=""
></script>

<style>
:root {
  --bg-main: #050509;
  --accent: #4dd0ff;
  --accent-soft: rgba(77, 208, 255, 0.3);
  --text-main: #ffffff;
  --text-soft: #cfd8dc;
  --tile-bg: rgba(12, 14, 20, 0.88);
  --tile-border: rgba(255, 255, 255, 0.16);
  --grid-gap: 10px;
  --grid-row-height: 220px;
}

/* Base */
* { box-sizing: border-box; }

body {
  margin: 0;
  padding: 0;
  font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
  color: var(--text-main);
  background:
    radial-gradient(circle at 0% 0%, #1a237e 0, transparent 55%),
    radial-gradient(circle at 100% 0%, #004d40 0, transparent 55%),
    radial-gradient(circle at 0% 100%, #b71c1c 0, transparent 55%),
    var(--bg-main);
  height: 100vh;
  overflow: hidden;
}

#canvas {
  position: relative;
  width: 100%;
  height: 100%;
  padding: 12px;
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(260px, 1fr));
  grid-auto-rows: var(--grid-row-height);
  gap: var(--grid-gap);
}

/* Subtle background pattern */
#canvas::before {
  content: "";
  position: absolute;
  inset: 0;
  background-image: radial-gradient(circle, rgba(255,255,255,0.05) 1px, transparent 0);
  background-size: 40px 40px;
  opacity: 0.18;
  pointer-events: none;
}

/* Tiles */
.tile {
  position: relative;
  background: var(--tile-bg);
  border-radius: 10px;
  border: 1px solid var(--tile-border);
  box-shadow:
    0 18px 40px rgba(0,0,0,0.7),
    0 0 35px rgba(0, 188, 212, 0.18);
  overflow: hidden;
  padding: 10px;
  display: flex;
  flex-direction: column;
  transition: transform 160ms ease-out, box-shadow 160ms ease-out,
              border-color 160ms ease-out, grid-column 160ms ease-out,
              grid-row 160ms ease-out;
}

/* Hybrid tech panel styling */
.tile::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: inherit;
  border: 1px solid rgba(255,255,255,0.03);
  background:
    linear-gradient(135deg, rgba(255,255,255,0.04), transparent 40%),
    repeating-linear-gradient(135deg,
      rgba(255,255,255,0.03) 0px,
      rgba(255,255,255,0.03) 1px,
      transparent 1px,
      transparent 3px);
  mix-blend-mode: screen;
  pointer-events: none;
  opacity: 0.9;
}
.tileContent {
  position: relative;
  z-index: 1;
  flex: 1;
  display: flex;
  flex-direction: column;
}

/* Tile header label */
.tileLabel {
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.12em;
  color: var(--text-soft);
  margin-bottom: 6px;
  display: flex;
  align-items: center;
  justify-content: space-between;
}
.tileLabel span {
  opacity: 0.9;
}

/* Edit chrome (only visible in edit mode) */
.tileEditChrome {
  position: absolute;
  inset: 0;
  border-radius: inherit;
  border: 1px dashed rgba(77, 208, 255, 0.7);
  box-shadow: 0 0 24px rgba(77, 208, 255, 0.35);
  pointer-events: none;
  opacity: 0;
  transition: opacity 140ms ease-out;
}
.tile.editModeActive .tileEditChrome {
  opacity: 1;
  pointer-events: none;
}
.tile.editModeActive {
  transform: translateY(-2px);
}

/* Drag handle */
.dragHandle {
  position: absolute;
  top: 6px;
  left: 50%;
  transform: translateX(-50%);
  width: 34px;
  height: 4px;
  border-radius: 999px;
  background: rgba(255,255,255,0.14);
  opacity: 0;
  transition: opacity 140ms ease-out;
}
.tile.editModeActive .dragHandle {
  opacity: 1;
}

/* Resize handle */
.resizeHandle {
  position: absolute;
  right: 4px;
  bottom: 4px;
  width: 14px;
  height: 14px;
  border-radius: 4px;
  border: 1px solid rgba(77,208,255,0.7);
  background: radial-gradient(circle at 0 100%, var(--accent) 0, transparent 70%);
  box-shadow: 0 0 8px rgba(77,208,255,0.8);
  cursor: nwse-resize;
  opacity: 0;
  transition: opacity 140ms ease-out;
}
.tile.editModeActive .resizeHandle {
  opacity: 1;
}

/* Tile gear */
.tileGearBtn {
  position: absolute;
  top: 6px;
  right: 6px;
  font-size: 14px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.75);
  color: var(--text-soft);
  padding: 2px 6px;
  cursor: pointer;
  opacity: 0;
  transition: opacity 140ms ease-out;
  z-index: 2;
}
.tile.editModeActive .tileGearBtn {
  opacity: 1;
}

/* Edit bar (only when editing) */
#editBar {
  position: absolute;
  top: 8px;
  left: 50%;
  transform: translateX(-50%);
  padding: 6px 12px;
  border-radius: 999px;
  background: rgba(5,5,10,0.88);
  border: 1px solid rgba(255,255,255,0.18);
  display: flex;
  align-items: center;
  gap: 10px;
  opacity: 0;
  pointer-events: none;
  transition: opacity 140ms ease-out, transform 140ms ease-out;
  z-index: 20;
}
#editBar.visible {
  opacity: 1;
  pointer-events: auto;
  transform: translateX(-50%) translateY(0);
}
#editBar span {
  font-size: 12px;
  color: var(--text-soft);
}
.editBarBtn {
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.8);
  color: var(--text-main);
  cursor: pointer;
}

/* Settings panel (per-tile, small overlay) */
.tileSettingsPanel {
  position: absolute;
  left: 8px;
  right: 8px;
  bottom: 8px;
  background: rgba(5,5,10,0.96);
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.2);
  padding: 6px 8px;
  font-size: 11px;
  z-index: 5;
  display: none;
}
.tileSettingsPanel h4 {
  margin: 0 0 4px 0;
  font-size: 11px;
  letter-spacing: 0.09em;
  text-transform: uppercase;
  color: var(--text-soft);
}
.ts-row {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
  margin-bottom: 4px;
}
.ts-row label {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.ts-row input,
.ts-row select {
  font-size: 11px;
  padding: 2px 4px;
  border-radius: 6px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.85);
  color: var(--text-main);
}
.ts-buttons {
  display: flex;
  justify-content: flex-end;
  gap: 6px;
  margin-top: 4px;
}
.ts-buttons button {
  font-size: 11px;
  padding: 2px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.85);
  color: var(--text-main);
  cursor: pointer;
}

/* Current weather / time tile */
.nowTime {
  font-size: 32px;
  font-weight: 600;
}
.nowDate {
  font-size: 13px;
  color: var(--text-soft);
}
.nowRow {
  display: flex;
  justify-content: space-between;
  margin-top: 8px;
  align-items: center;
}
.nowWeatherMain {
  display: flex;
  align-items: center;
  gap: 8px;
}
.nowWeatherMain img {
  width: 52px;
  height: 52px;
}
.nowTemp {
  font-size: 26px;
  font-weight: 600;
}
.nowDesc {
  font-size: 13px;
  color: var(--text-soft);
  text-transform: capitalize;
}
.nowRain {
  font-size: 13px;
  color: var(--accent);
}

/* Hourly tile */
.hourlyStrip {
  display: flex;
  gap: 10px;
  overflow-x: auto;
  padding-bottom: 4px;
}
.hourlyStrip::-webkit-scrollbar { height: 4px; }
.hourlyStrip::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.25);
  border-radius: 999px;
}
.hourItem {
  min-width: 70px;
  text-align: center;
  font-size: 12px;
  color: var(--text-soft);
}
.hourItem img {
  width: 26px;
  height: 26px;
}
.hourTemp {
  font-weight: 600;
  color: var(--accent);
}
.hourRain {
  font-size: 11px;
  color: var(--accent);
}

/* Radar */
#radarMap {
  width: 100%;
  height: 100%;
  border-radius: 8px;
}
.leaflet-container {
  background: transparent;
}

/* Schedule */
.scheduleList {
  margin-top: 6px;
  overflow-y: auto;
  font-size: 13px;
}
.scheduleList::-webkit-scrollbar { width: 4px; }
.scheduleList::-webkit-scrollbar-thumb {
  background: rgba(255,255,255,0.25);
  border-radius: 999px;
}
.scheduleItem {
  display: flex;
  gap: 6px;
  padding: 3px 0;
  border-bottom: 1px dashed rgba(255,255,255,0.14);
}
.scheduleTime {
  min-width: 68px;
  font-weight: 600;
  color: var(--accent);
  font-size: 12px;
}
.scheduleTitle {
  flex: 1;
}
.scheduleEmpty {
  font-size: 13px;
  color: var(--text-soft);
  margin-top: 8px;
}

/* Camera */
.camView {
  flex: 1;
  border-radius: 8px;
  overflow: hidden;
  background: #000;
}
.camView img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}

/* Camera discovery */
.camDiscover {
  display: flex;
  flex-direction: column;
  gap: 6px;
  font-size: 12px;
}
.camDiscoverStatus {
  color: var(--text-soft);
}
.camDiscoverPreview {
  flex: 1;
  border-radius: 8px;
  overflow: hidden;
  border: 1px solid rgba(255,255,255,0.3);
  background: #000;
  position: relative;
}
.camDiscoverPreview img {
  width: 100%;
  height: 100%;
  object-fit: cover;
}
.camDiscoverMeta {
  position: absolute;
  left: 6px;
  bottom: 4px;
  padding: 3px 6px;
  border-radius: 6px;
  background: rgba(0,0,0,0.7);
  font-size: 11px;
}
.camDiscoverButtons {
  display: flex;
  justify-content: space-between;
  gap: 6px;
}
.camDiscoverButtons button {
  flex: 1;
  font-size: 12px;
  padding: 4px 6px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.85);
  color: var(--text-main);
  cursor: pointer;
}

/* Speed tile */
.speedStats {
  margin-top: 4px;
  font-size: 13px;
}
.speedLine {
  display: flex;
  justify-content: space-between;
  margin-bottom: 4px;
}
.speedLabel {
  color: var(--text-soft);
  font-size: 11px;
  text-transform: uppercase;
  letter-spacing: 0.11em;
}
.speedValue {
  font-weight: 600;
}
.speedBtn {
  margin-top: auto;
  align-self: flex-start;
  font-size: 12px;
  padding: 4px 8px;
  border-radius: 999px;
  border: 1px solid rgba(255,255,255,0.25);
  background: rgba(0,0,0,0.9);
  color: var(--text-main);
  cursor: pointer;
}
.statusGood { color: #8bc34a; }
.statusWarn { color: #ffc107; }
.statusBad  { color: #ff5252; }

/* Utility */
.hidden { display: none; }
</style>
</head>
<body>

<div id="canvas"></div>

<!-- Edit bar (appears only in edit mode) -->
<div id="editBar">
  <span>Layout edit mode</span>
  <button id="editDoneBtn" class="editBarBtn">Done</button>
  <button id="editSettingsBtn" class="editBarBtn">Settings (basic)</button>
</div>

<script>
/* ========= GLOBAL CONFIG ========= */
const API_KEY = "ce57b328ddd2af95c06b77dc11a49bf6";
const STORAGE_KEY = "abstruse_dashboard_v2";
const EDIT_LONGPRESS_MS = 700;

/* ========= STATE ========= */
let state = null;
let editMode = false;
let lastLat = null;
let lastLon = null;
let gpsTried = false;

let radarMap = null;
let radarBaseLayer = null;
let radarLayer = null;
let radarFrames = [];
let radarFrameIndex = 0;
let radarAnimTimer = null;
let radarHost = "https://tilecache.rainviewer.com";

/* ========= DEFAULT STATE ========= */
const defaultState = {
  cameraScanSubnetPrefix: "192.168.1.",
  icsRaw: "",
  tiles: [
    {
      id: "now",
      type: "now",
      label: "Now / Weather",
      colSpan: 2,
      rowSpan: 1,
      order: 1,
      config: {}
    },
    {
      id: "hourly",
      type: "hourly",
      label: "Hourly Forecast",
      colSpan: 2,
      rowSpan: 1,
      order: 2,
      config: {}
    },
    {
      id: "schedule",
      type: "schedule",
      label: "Schedule",
      colSpan: 2,
      rowSpan: 2,
      order: 3,
      config: {
        showPast: false,
        maxEvents: 20,
        timeFormat24: false
      }
    },
    {
      id: "cam1",
      type: "cam",
      label: "Cam 1",
      colSpan: 1,
      rowSpan: 1,
      order: 4,
      config: {
        url: "http://192.168.1.78",
        username: "",
        password: ""
      }
    },
    {
      id: "cam2",
      type: "cam",
      label: "Cam 2",
      colSpan: 1,
      rowSpan: 1,
      order: 5,
      config: {
        url: "http://192.168.1.34",
        username: "",
        password: ""
      }
    },
    {
      id: "cam3",
      type: "cam",
      label: "Cam 3",
      colSpan: 1,
      rowSpan: 1,
      order: 6,
      config: {
        url: "http://192.168.1.94",
        username: "",
        password: ""
      }
    },
    {
      id: "radar",
      type: "radar",
      label: "Radar",
      colSpan: 2,
      rowSpan: 2,
      order: 7,
      config: {
        rain: true,
        snow: false,
        clouds: false,
        animSpeedMs: 700,
        opacity: 0.7,
        baseLayer: "dark",
        gpsLock: true
      }
    },
    {
      id: "speed",
      type: "speed",
      label: "Speed / Ping",
      colSpan: 1,
      rowSpan: 1,
      order: 8,
      config: {
        speedUrl: "https://www.abstrusenetworks.com/speedtest.bin",
        pingTarget: "https://dns.google/resolve?name=google.com"
      }
    },
    {
      id: "camDiscover",
      type: "camAuto",
      label: "Camera Discovery",
      colSpan: 1,
      rowSpan: 1,
      order: 9,
      config: {
        discoveredIp: "",
        discoveredPath: "",
        username: "",
        password: ""
      }
    }
  ]
};

/* ========= PERSISTENCE ========= */
function loadState() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return JSON.parse(JSON.stringify(defaultState));
    const parsed = JSON.parse(raw);
    // rudimentary merge
    const base = JSON.parse(JSON.stringify(defaultState));
    base.cameraScanSubnetPrefix = parsed.cameraScanSubnetPrefix || base.cameraScanSubnetPrefix;
    base.icsRaw = parsed.icsRaw || "";
    if (parsed.tiles) {
      for (const t of base.tiles) {
        const existing = parsed.tiles.find(p => p.id === t.id);
        if (existing) {
          t.colSpan = existing.colSpan || t.colSpan;
          t.rowSpan = existing.rowSpan || t.rowSpan;
          t.order   = existing.order   || t.order;
          t.label   = existing.label   || t.label;
          t.config  = { ...t.config, ...(existing.config || {}) };
        }
      }
    }
    return base;
  } catch (e) {
    console.error("State load error", e);
    return JSON.parse(JSON.stringify(defaultState));
  }
}
function saveState() {
  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
  } catch (e) {
    console.error("State save error", e);
  }
}

/* ========= WEATHER / LOCATION ========= */
async function ensureLocationAndWeather() {
  if (!gpsTried && lastLat == null && lastLon == null && navigator.geolocation) {
    gpsTried = true;
    navigator.geolocation.getCurrentPosition(
      pos => {
        lastLat = pos.coords.latitude;
        lastLon = pos.coords.longitude;
        fetchWeather();
      },
      err => {
        console.warn("GPS error, using fallback", err);
        lastLat = 36.03;
        lastLon = -84.15;
        fetchWeather();
      },
      { enableHighAccuracy: true, timeout: 5000 }
    );
  } else {
    if (lastLat == null || lastLon == null) {
      lastLat = 36.03;
      lastLon = -84.15;
    }
    fetchWeather();
  }
}

async function fetchWeather() {
  try {
    const LAT = lastLat;
    const LON = lastLon;
    const url =
      "https://api.openweathermap.org/data/2.5/forecast?lat=" +
      encodeURIComponent(LAT) +
      "&lon=" + encodeURIComponent(LON) +
      "&units=imperial&appid=" + encodeURIComponent(API_KEY);

    const res = await fetch(url);
    const data = await res.json();
    if (!data.list || !data.list.length) return;

    window.__weatherData = data;
    renderNowTile();
    renderHourlyTile();
    if (getTile("radar")) {
      initRadar();
    }
  } catch (e) {
    console.error("Weather error", e);
  }
}

/* ========= TILES HELPERS ========= */
function getTile(id) {
  return state.tiles.find(t => t.id === id);
}
function sortTiles() {
  state.tiles.sort((a, b) => a.order - b.order);
}

/* ========= RENDER ALL TILES ========= */
function renderAllTiles() {
  const canvas = document.getElementById("canvas");
  canvas.innerHTML = "";
  sortTiles();

  state.tiles.forEach(tileCfg => {
    const tile = document.createElement("div");
    tile.className = "tile";
    tile.dataset.id = tileCfg.id;
    tile.style.gridColumn = "span " + tileCfg.colSpan;
    tile.style.gridRow = "span " + tileCfg.rowSpan;

    const editChrome = document.createElement("div");
    editChrome.className = "tileEditChrome";
    tile.appendChild(editChrome);

    const dragHandle = document.createElement("div");
    dragHandle.className = "dragHandle";
    tile.appendChild(dragHandle);

    const resizeHandle = document.createElement("div");
    resizeHandle.className = "resizeHandle";
    tile.appendChild(resizeHandle);

    const gearBtn = document.createElement("button");
    gearBtn.className = "tileGearBtn";
    gearBtn.textContent = "‚öô";
    tile.appendChild(gearBtn);

    const content = document.createElement("div");
    content.className = "tileContent";
    tile.appendChild(content);

    const header = document.createElement("div");
    header.className = "tileLabel";
    header.innerHTML = `<span>${tileCfg.label}</span>`;
    content.appendChild(header);

    // Tile-specific content
    if (tileCfg.type === "now") {
      content.appendChild(buildNowInner());
    } else if (tileCfg.type === "hourly") {
      content.appendChild(buildHourlyInner());
    } else if (tileCfg.type === "schedule") {
      content.appendChild(buildScheduleInner());
    } else if (tileCfg.type === "radar") {
      const mapWrapper = document.createElement("div");
      mapWrapper.style.flex = "1";
      const m = document.createElement("div");
      m.id = "radarMap";
      mapWrapper.appendChild(m);
      content.appendChild(mapWrapper);
    } else if (tileCfg.type === "cam") {
      const cv = document.createElement("div");
      cv.className = "camView";
      const img = document.createElement("img");
      img.alt = tileCfg.label;
      img.dataset.camId = tileCfg.id;
      cv.appendChild(img);
      content.appendChild(cv);
      setupCamStream(img, tileCfg);
    } else if (tileCfg.type === "camAuto") {
      content.appendChild(buildCamDiscoverInner(tileCfg));
    } else if (tileCfg.type === "speed") {
      content.appendChild(buildSpeedInner(tileCfg));
    }

    // settings panel
    const settingsPanel = document.createElement("div");
    settingsPanel.className = "tileSettingsPanel";
    settingsPanel.innerHTML = buildTileSettingsHtml(tileCfg);
    tile.appendChild(settingsPanel);

    // wire settings
    gearBtn.addEventListener("click", e => {
      e.stopPropagation();
      if (!editMode) return;
      settingsPanel.style.display =
        settingsPanel.style.display === "none" || !settingsPanel.style.display
          ? "block"
          : "none";
      attachSettingsHandlers(tileCfg, tile, settingsPanel);
    });

    canvas.appendChild(tile);

    // editing interactions
    setupTileDrag(tile, dragHandle, tileCfg);
    setupTileResize(tile, resizeHandle, tileCfg);
  });

  applyEditModeVisuals();
  renderScheduleTile();
  if (getTile("radar")) initRadar();
}

/* ========= TILE-SPECIFIC BUILDERS ========= */
function buildNowInner() {
  const wrapper = document.createElement("div");
  const timeRow = document.createElement("div");
  timeRow.className = "nowTime";
  timeRow.id = "nowTime";
  wrapper.appendChild(timeRow);

  const dateRow = document.createElement("div");
  dateRow.className = "nowDate";
  dateRow.id = "nowDate";
  wrapper.appendChild(dateRow);

  const row = document.createElement("div");
  row.className = "nowRow";

  const left = document.createElement("div");
  left.className = "nowWeatherMain";
  left.innerHTML = `
    <img id="nowIcon" alt="Weather">
    <div>
      <div class="nowTemp" id="nowTemp">--¬∞F</div>
      <div class="nowDesc" id="nowDesc">Loading...</div>
    </div>
  `;

  const right = document.createElement("div");
  right.style.textAlign = "right";
  right.innerHTML = `
    <div class="nowRain" id="nowRain">--% üåßÔ∏è</div>
  `;

  row.appendChild(left);
  row.appendChild(right);

  wrapper.appendChild(row);
  return wrapper;
}

function buildHourlyInner() {
  const wrapper = document.createElement("div");
  const strip = document.createElement("div");
  strip.className = "hourlyStrip";
  strip.id = "hourlyStrip";
  wrapper.appendChild(strip);
  return wrapper;
}

function buildScheduleInner() {
  const wrapper = document.createElement("div");
  const dateLabel = document.createElement("div");
  dateLabel.id = "scheduleDateLabel";
  dateLabel.style.fontSize = "13px";
  dateLabel.style.color   = "var(--text-soft)";
  wrapper.appendChild(dateLabel);

  const list = document.createElement("div");
  list.className = "scheduleList";
  list.id = "scheduleList";
  wrapper.appendChild(list);
  return wrapper;
}

function buildCamDiscoverInner(tileCfg) {
  const wrapper = document.createElement("div");
  wrapper.className = "camDiscover";

  const status = document.createElement("div");
  status.className = "camDiscoverStatus";
  status.textContent = "Idle. Hold scan to search.";
  wrapper.appendChild(status);

  const preview = document.createElement("div");
  preview.className = "camDiscoverPreview";
  const img = document.createElement("img");
  img.className = "camDiscoverImg";
  img.style.display = "none";
  preview.appendChild(img);

  const meta = document.createElement("div");
  meta.className = "camDiscoverMeta";
  meta.textContent = "No camera discovered yet.";
  preview.appendChild(meta);

  wrapper.appendChild(preview);

  const btnRow = document.createElement("div");
  btnRow.className = "camDiscoverButtons";
  const scanBtn = document.createElement("button");
  scanBtn.textContent = "Scan subnet";
  const applyBtn = document.createElement("button");
  applyBtn.textContent = "Apply to Cam 1";
  btnRow.appendChild(scanBtn);
  btnRow.appendChild(applyBtn);
  wrapper.appendChild(btnRow);

  scanBtn.addEventListener("click", async () => {
    scanBtn.disabled = true;
    applyBtn.disabled = true;
    await runCameraDiscovery(wrapper, tileCfg);
    scanBtn.disabled = false;
    applyBtn.disabled = false;
  });

  applyBtn.addEventListener("click", () => {
    const cfg = tileCfg.config;
    if (!cfg.discoveredIp || !cfg.discoveredPath) {
      alert("No discovered camera yet. Scan first.");
      return;
    }
    const cam1 = getTile("cam1");
    if (cam1) {
      cam1.config.url = "http://" + cfg.discoveredIp;
      cam1.config.username = cfg.username || "";
      cam1.config.password = cfg.password || "";
      saveState();
      renderAllTiles();
      alert("Applied to Cam 1.");
    }
  });

  // existing discovered info?
  if (tileCfg.config.discoveredIp && tileCfg.config.discoveredPath) {
    const url = buildDiscoveredUrl(tileCfg.config);
    img.src = url;
    img.style.display = "block";
    meta.textContent = tileCfg.config.discoveredIp + " " + tileCfg.config.discoveredPath;
    status.textContent = "Previously discovered camera.";
  }

  return wrapper;
}

function buildSpeedInner(tileCfg) {
  const wrapper = document.createElement("div");
  wrapper.style.display = "flex";
  wrapper.style.flexDirection = "column";
  wrapper.style.height = "100%";

  const stats = document.createElement("div");
  stats.className = "speedStats";
  stats.innerHTML = `
    <div class="speedLine">
      <div class="speedLabel">Ping</div>
      <div class="speedValue speedPingVal statusWarn">-- ms</div>
    </div>
    <div class="speedLine">
      <div class="speedLabel">Download</div>
      <div class="speedValue speedDownVal statusWarn">-- Mbps</div>
    </div>
  `;
  wrapper.appendChild(stats);

  const btn = document.createElement("button");
  btn.className = "speedBtn";
  btn.textContent = "Run speed & ping";
  btn.addEventListener("click", () => {
    runPingForTile();
    runSpeedTestForTile();
  });
  wrapper.appendChild(btn);

  return wrapper;
}

/* ========= NOW TILE RENDER ========= */
function updateClock() {
  const now = new Date();
  const tEl = document.getElementById("nowTime");
  const dEl = document.getElementById("nowDate");
  if (!tEl || !dEl) return;
  tEl.textContent = now.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit" });
  dEl.textContent = now.toLocaleDateString([], {
    weekday: "long",
    month: "long",
    day: "numeric",
    year: "numeric"
  });
}
setInterval(updateClock, 1000);

function renderNowTile() {
  if (!window.__weatherData) return;
  const data = window.__weatherData;
  const current = data.list[0];

  const iconEl = document.getElementById("nowIcon");
  const tempEl = document.getElementById("nowTemp");
  const descEl = document.getElementById("nowDesc");
  const rainEl = document.getElementById("nowRain");
  if (!iconEl) return;

  const icon = current.weather[0].icon;
  const temp = Math.round(current.main.temp);
  const desc = current.weather[0].description;
  const pop  = Math.round((current.pop || 0) * 100);

  iconEl.src = "https://openweathermap.org/img/wn/" + icon + "@2x.png";
  tempEl.textContent = temp + "¬∞F";
  descEl.textContent = desc;
  rainEl.textContent = pop + "% üåßÔ∏è";
}

/* ========= HOURLY TILE RENDER ========= */
function renderHourlyTile() {
  if (!window.__weatherData) return;
  const strip = document.getElementById("hourlyStrip");
  if (!strip) return;
  strip.innerHTML = "";
  const list = window.__weatherData.list.slice(0, 12);
  list.forEach(hr => {
    const t = new Date(hr.dt * 1000).toLocaleTimeString([], { hour: "numeric" });
    const hrTemp = Math.round(hr.main.temp);
    const icon = hr.weather[0].icon;
    const pop = Math.round((hr.pop || 0) * 100);
    const item = document.createElement("div");
    item.className = "hourItem";
    item.innerHTML = `
      <div>${t}</div>
      <img src="https://openweathermap.org/img/wn/${icon}.png" alt="">
      <div class="hourTemp">${hrTemp}¬∞F</div>
      <div class="hourRain">${pop}% üåßÔ∏è</div>
    `;
    strip.appendChild(item);
  });
}

/* ========= RADAR ========= */
async function initRadar() {
  const mapDiv = document.getElementById("radarMap");
  if (!mapDiv) return;
  if (typeof L === "undefined") {
    console.error("Leaflet not available");
    return;
  }

  const radarTile = getTile("radar");
  const cfg = radarTile.config;
  const lat = (lastLat != null && cfg.gpsLock) ? lastLat : 36.03;
  const lon = (lastLon != null && cfg.gpsLock) ? lastLon : -84.15;

  if (!radarMap) {
    radarMap = L.map("radarMap", {
      zoomControl: true,
      attributionControl: false
    });
  } else {
    radarMap.invalidateSize();
  }

  radarMap.setView([lat, lon], 8);

  if (radarBaseLayer) {
    radarMap.removeLayer(radarBaseLayer);
  }
  const base = cfg.baseLayer || "dark";
  if (base === "light") {
    radarBaseLayer = L.tileLayer(
      "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 18 }
    ).addTo(radarMap);
  } else if (base === "osm") {
    radarBaseLayer = L.tileLayer(
      "https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png", { maxZoom: 18 }
    ).addTo(radarMap);
  } else {
    radarBaseLayer = L.tileLayer(
      "https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}.png", { maxZoom: 18 }
    ).addTo(radarMap);
  }

  await loadRadarData();
}

async function loadRadarData() {
  try {
    const res = await fetch("https://api.rainviewer.com/public/weather-maps.json");
    const data = await res.json();
    radarHost = data.host || "https://tilecache.rainviewer.com";
    const past = data.radar && data.radar.past ? data.radar.past : [];
    if (!past.length) return;
    radarFrames = past.slice(-8);
    radarFrameIndex = 0;
    updateRadarLayer();

    if (radarAnimTimer) clearInterval(radarAnimTimer);
    const cfg = getTile("radar").config;
    const speed = cfg.animSpeedMs || 700;
    radarAnimTimer = setInterval(() => {
      radarFrameIndex = (radarFrameIndex + 1) % radarFrames.length;
      updateRadarLayer();
    }, speed);
  } catch (e) {
    console.error("Radar data error", e);
  }
}

function radarTileUrl(framePath) {
  return radarHost + framePath + "/256/{z}/{x}/{y}/2/1_1.png";
}

function updateRadarLayer() {
  if (!radarMap || !radarFrames.length) return;
  const frame = radarFrames[radarFrameIndex];
  const cfg = getTile("radar").config;
  const urlTemplate = radarTileUrl(frame.path);
  const opacity = cfg.rain ? (cfg.opacity || 0.7) : 0.0;

  if (radarLayer) {
    radarLayer.setUrl(urlTemplate);
    radarLayer.setOpacity(opacity);
  } else {
    radarLayer = L.tileLayer(urlTemplate, { opacity });
    radarLayer.addTo(radarMap);
  }
}

/* ========= ICS SCHEDULE ========= */
function parseICSTime(dtVal) {
  const datePart = dtVal.slice(0, 8);
  const year = parseInt(datePart.slice(0, 4), 10);
  const month = parseInt(datePart.slice(4, 6), 10) - 1;
  const day = parseInt(datePart.slice(6, 8), 10);
  if (dtVal.length > 8) {
    const timePart = dtVal.slice(9, 15);
    const hour = parseInt(timePart.slice(0, 2), 10);
    const minute = parseInt(timePart.slice(2, 4), 10);
    const second = parseInt(timePart.slice(4, 6), 10);
    return new Date(Date.UTC(year, month, day, hour, minute, second));
  } else {
    return new Date(year, month, day);
  }
}

function formatTimeLabel(dateObj, allDay, use24h) {
  if (allDay) return "All day";
  return dateObj.toLocaleTimeString([], { hour: "numeric", minute: "2-digit", hour12: !use24h });
}

function renderScheduleTile() {
  const dateLabel = document.getElementById("scheduleDateLabel");
  const list = document.getElementById("scheduleList");
  if (!dateLabel || !list) return;

  const now = new Date();
  const todayKey = now.toISOString().slice(0, 10).replace(/-/g, "");
  dateLabel.textContent = now.toLocaleDateString([], {
    weekday: "long",
    month: "long",
    day: "numeric"
  });

  const text = (state.icsRaw || "").trim();
  if (!text) {
    list.innerHTML = "<div class=\"scheduleEmpty\">Paste ICS in config (not yet wired UI) to see schedule.</div>";
    return;
  }

  const cfg = getTile("schedule").config;
  const showPast = !!cfg.showPast;
  const maxEvents = cfg.maxEvents || 20;
  const use24h = !!cfg.timeFormat24;

  const blocks = text.split("BEGIN:VEVENT").slice(1);
  const events = [];

  blocks.forEach(blockRaw => {
    const block = "BEGIN:VEVENT" + blockRaw;
    const lines = block.split(/\r?\n/);
    const dtStartLine = lines.find(l => l.startsWith("DTSTART"));
    const summaryLine = lines.find(l => l.startsWith("SUMMARY:"));
    if (!dtStartLine || !summaryLine) return;
    const dtVal = dtStartLine.split(":")[1].trim();
    const dateKey = dtVal.slice(0, 8);
    if (dateKey !== todayKey) return;
    const allDay = dtVal.length === 8;
    const startDate = parseICSTime(dtVal);
    const title = summaryLine.slice("SUMMARY:".length).trim();
    if (!showPast && !allDay && startDate < now) return;
    events.push({ start: startDate, allDay, title });
  });

  events.sort((a, b) => a.start - b.start);
  list.innerHTML = "";

  if (!events.length) {
    list.innerHTML = "<div class=\"scheduleEmpty\">No events for the rest of today.</div>";
  } else {
    events.slice(0, maxEvents).forEach(evt => {
      const item = document.createElement("div");
      item.className = "scheduleItem";
      const timeLabel = formatTimeLabel(evt.start, evt.allDay, use24h);
      item.innerHTML = `
        <div class="scheduleTime">${timeLabel}</div>
        <div class="scheduleTitle">${evt.title}</div>
      `;
      list.appendChild(item);
    });
  }
}

/* ========= CAMERA STREAMS ========= */
function buildCamStreamUrl(base, user, pass) {
  try {
    let u = new URL(base);
    u.pathname = "/cgi-bin/mjpg/video.cgi";
    u.search = "channel=1&subtype=1&t=" + Date.now();
    if (user) u.username = user;
    if (pass) u.password = pass;
    return u.toString();
  } catch (e) {
    console.error("Cam URL error", e);
    return base;
  }
}
function setupCamStream(img, cfg) {
  function refresh() {
    img.src = buildCamStreamUrl(cfg.config.url, cfg.config.username, cfg.config.password);
  }
  refresh();
  setInterval(refresh, 20000);
}

/* ========= CAMERA DISCOVERY ========= */
function probeImage(url, timeoutMs = 2000) {
  return new Promise(resolve => {
    const img = new Image();
    let done = false;
    const timer = setTimeout(() => {
      if (done) return;
      done = true;
      resolve(false);
    }, timeoutMs);
    img.onload = () => {
      if (done) return;
      done = true;
      clearTimeout(timer);
      resolve(true);
    };
    img.onerror = () => {
      if (done) return;
      done = true;
      clearTimeout(timer);
      resolve(false);
    };
    img.src = url;
  });
}
function buildDiscoveredUrl(cfg) {
  try {
    const base = "http://" + cfg.discoveredIp;
    let u = new URL(base);
    u.pathname = cfg.discoveredPath.split("?")[0];
    const qs = cfg.discoveredPath.includes("?") ? cfg.discoveredPath.split("?")[1] : "";
    const ts = "t=" + Date.now();
    u.search = qs ? (qs + "&" + ts) : ts;
    if (cfg.username) u.username = cfg.username;
    if (cfg.password) u.password = cfg.password;
    return u.toString();
  } catch {
    return "";
  }
}

async function runCameraDiscovery(wrapper, tileCfg) {
  const statusEl = wrapper.querySelector(".camDiscoverStatus");
  const imgEl = wrapper.querySelector(".camDiscoverImg");
  const metaEl = wrapper.querySelector(".camDiscoverMeta");
  const subnet = state.cameraScanSubnetPrefix || "192.168.1.";
  statusEl.textContent = "Scanning subnet " + subnet + "1‚Äì254...";

  const paths = [
    "/cgi-bin/mjpg/video.cgi?channel=1&subtype=1",
    "/cgi-bin/mjpg/video.cgi?channel=0&subtype=1",
    "/mjpeg",
    "/mjpegstream",
    "/video.mjpeg",
    "/cgi-bin/video.cgi",
    "/cgi-bin/stream",
    "/snapshot.jpg",
    "/image.jpg",
    "/cgi-bin/snapshot.cgi"
  ];
  const creds = [
    { user: "", pass: "" },
    { user: "admin", pass: "admin" },
    { user: "admin", pass: "" },
    { user: "admin", pass: "12345" },
    { user: "user",  pass: "user" },
    { user: "root",  pass: "root" }
  ];

  let found = null;

  outer:
  for (let host = 1; host <= 254; host++) {
    const ip = subnet + host;
    statusEl.textContent = "Testing " + ip + "...";
    for (const path of paths) {
      for (const c of creds) {
        try {
          let u = new URL("http://" + ip);
          u.pathname = path.split("?")[0];
          const qs = path.includes("?") ? path.split("?")[1] : "";
          const ts = "t=" + Date.now();
          u.search = qs ? (qs + "&" + ts) : ts;
          if (c.user) u.username = c.user;
          if (c.pass) u.password = c.pass;
          const testUrl = u.toString();
          const ok = await probeImage(testUrl, 1400);
          if (ok) {
            found = {
              ip,
              path,
              username: c.user,
              password: c.pass
            };
            break outer;
          }
        } catch (e) {
          console.error("Probe error", e);
        }
      }
    }
  }

  if (!found) {
    statusEl.textContent = "Scan complete ‚Äî no cameras found.";
    imgEl.style.display = "none";
    metaEl.textContent = "No match.";
    return;
  }

  tileCfg.config.discoveredIp = found.ip;
  tileCfg.config.discoveredPath = found.path;
  tileCfg.config.username = found.username;
  tileCfg.config.password = found.password;
  saveState();

  statusEl.textContent = "Camera found at " + found.ip;
  const url = buildDiscoveredUrl(tileCfg.config);
  imgEl.src = url;
  imgEl.style.display = "block";
  metaEl.textContent = found.ip + " " + found.path +
    (found.username ? (" [" + found.username + "]") : "");
}

/* ========= SPEED / PING ========= */
function setStatusColor(el, val, type) {
  let cls = "statusGood";
  if (type === "ping") {
    if (val > 200) cls = "statusBad";
    else if (val > 80) cls = "statusWarn";
  } else if (type === "speed") {
    if (val < 5) cls = "statusBad";
    else if (val < 20) cls = "statusWarn";
  }
  el.classList.remove("statusGood", "statusWarn", "statusBad");
  el.classList.add(cls);
}
async function runPingForTile() {
  const tile = document.querySelector('.tile[data-id="speed"]');
  if (!tile) return;
  const pingEl = tile.querySelector(".speedPingVal");
  const cfg = getTile("speed").config;
  const url = cfg.pingTarget || defaultState.tiles.find(t => t.id === "speed").config.pingTarget;
  const start = performance.now();
  try {
    await fetch(url, { cache: "no-store" });
    const ms = Math.round(performance.now() - start);
    pingEl.textContent = ms + " ms";
    setStatusColor(pingEl, ms, "ping");
  } catch {
    pingEl.textContent = "offline";
    pingEl.classList.remove("statusGood", "statusWarn");
    pingEl.classList.add("statusBad");
  }
}
async function runSpeedTestForTile() {
  const tile = document.querySelector('.tile[data-id="speed"]');
  if (!tile) return;
  const speedEl = tile.querySelector(".speedDownVal");
  const cfg = getTile("speed").config;
  const url = cfg.speedUrl || defaultState.tiles.find(t => t.id === "speed").config.speedUrl;
  try {
    const start = performance.now();
    const response = await fetch(url + (url.includes("?") ? "&" : "?") + "t=" + Date.now(), {
      cache: "no-store"
    });
    let bytes = 0;
    if (response.body) {
      const reader = response.body.getReader();
      while (true) {
        const { done, value } = await reader.read();
        if (done) break;
        bytes += value.length;
      }
    } else {
      const buf = await response.arrayBuffer();
      bytes = buf.byteLength;
    }
    const duration = (performance.now() - start) / 1000;
    const bits = bytes * 8;
    const mbps = (bits / duration) / 1e6;
    speedEl.textContent = mbps.toFixed(1) + " Mbps";
    setStatusColor(speedEl, mbps, "speed");
  } catch (e) {
    console.error("Speedtest error", e);
    speedEl.textContent = "ERR";
    speedEl.classList.remove("statusGood", "statusWarn");
    speedEl.classList.add("statusBad");
  }
}

/* ========= TILE SETTINGS (very light for now) ========= */
function buildTileSettingsHtml(tileCfg) {
  let html = `
    <h4>${tileCfg.label}</h4>
    <div class="ts-row">
      <label>Label
        <input type="text" class="ts-label" value="${tileCfg.label}">
      </label>
    </div>
  `;
  if (tileCfg.type === "cam") {
    html += `
      <div class="ts-row">
        <label>Base URL
          <input type="text" class="ts-cam-url" value="${tileCfg.config.url || ""}">
        </label>
      </div>
      <div class="ts-row">
        <label>Username
          <input type="text" class="ts-cam-user" value="${tileCfg.config.username || ""}">
        </label>
        <label>Password
          <input type="password" class="ts-cam-pass" value="${tileCfg.config.password || ""}">
        </label>
      </div>
    `;
  } else if (tileCfg.type === "radar") {
    html += `
      <div class="ts-row">
        <label><input type="checkbox" class="ts-rain" ${tileCfg.config.rain ? "checked" : ""}> Rain</label>
        <label><input type="checkbox" class="ts-gps" ${tileCfg.config.gpsLock ? "checked" : ""}> GPS lock</label>
      </div>
    `;
  } else if (tileCfg.type === "speed") {
    html += `
      <div class="ts-row">
        <label>Speed URL
          <input type="text" class="ts-speed-url" value="${tileCfg.config.speedUrl || ""}">
        </label>
      </div>
      <div class="ts-row">
        <label>Ping URL
          <input type="text" class="ts-ping-url" value="${tileCfg.config.pingTarget || ""}">
        </label>
      </div>
    `;
  }
  html += `
    <div class="ts-buttons">
      <button class="ts-reset">Reset</button>
      <button class="ts-save">Save</button>
    </div>
  `;
  return html;
}

function attachSettingsHandlers(tileCfg, tileEl, panel) {
  const resetBtn = panel.querySelector(".ts-reset");
  const saveBtn  = panel.querySelector(".ts-save");

  resetBtn.onclick = () => {
    const def = defaultState.tiles.find(t => t.id === tileCfg.id);
    if (!def) return;
    tileCfg.label   = def.label;
    tileCfg.colSpan = def.colSpan;
    tileCfg.rowSpan = def.rowSpan;
    tileCfg.config  = JSON.parse(JSON.stringify(def.config));
    saveState();
    renderAllTiles();
  };

  saveBtn.onclick = () => {
    const lbl = panel.querySelector(".ts-label");
    if (lbl) tileCfg.label = lbl.value.trim() || tileCfg.label;

    if (tileCfg.type === "cam") {
      const u = panel.querySelector(".ts-cam-url");
      const usr = panel.querySelector(".ts-cam-user");
      const pw = panel.querySelector(".ts-cam-pass");
      tileCfg.config.url = u.value.trim() || tileCfg.config.url;
      tileCfg.config.username = usr.value.trim();
      tileCfg.config.password = pw.value;
    } else if (tileCfg.type === "radar") {
      const rain = panel.querySelector(".ts-rain");
      const gps  = panel.querySelector(".ts-gps");
      tileCfg.config.rain = !!rain?.checked;
      tileCfg.config.gpsLock = !!gps?.checked;
    } else if (tileCfg.type === "speed") {
      const su = panel.querySelector(".ts-speed-url");
      const pu = panel.querySelector(".ts-ping-url");
      tileCfg.config.speedUrl = su.value.trim() || tileCfg.config.speedUrl;
      tileCfg.config.pingTarget = pu.value.trim() || tileCfg.config.pingTarget;
    }

    saveState();
    renderAllTiles();
  };
}

/* ========= EDIT MODE & INTERACTIONS ========= */
const editBar = document.getElementById("editBar");
const editDoneBtn = document.getElementById("editDoneBtn");
const editSettingsBtn = document.getElementById("editSettingsBtn");

function setEditMode(on) {
  editMode = on;
  applyEditModeVisuals();
}
function applyEditModeVisuals() {
  const tiles = document.querySelectorAll(".tile");
  tiles.forEach(t => {
    if (editMode) t.classList.add("editModeActive");
    else t.classList.remove("editModeActive");
  });
  if (editMode) {
    editBar.classList.add("visible");
  } else {
    editBar.classList.remove("visible");
  }
}
editDoneBtn.addEventListener("click", () => setEditMode(false));
editSettingsBtn.addEventListener("click", () => {
  alert("Global settings drawer not wired yet; per-tile settings via each tile gear.");
});

/* Long press on empty canvas to enter edit */
(function setupCanvasLongPress() {
  const canvas = document.getElementById("canvas");
  let timer = null;
  let startTarget = null;

  function startPress(e) {
    // only if background
    if (e.target !== canvas) return;
    if (timer) clearTimeout(timer);
    startTarget = e.target;
    timer = setTimeout(() => {
      setEditMode(true);
      timer = null;
    }, EDIT_LONGPRESS_MS);
  }
  function endPress() {
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
  }

  canvas.addEventListener("pointerdown", startPress);
  canvas.addEventListener("pointerup", endPress);
  canvas.addEventListener("pointerleave", endPress);
})();

/* Drag & reorder */
function setupTileDrag(tileEl, dragHandle, tileCfg) {
  let dragging = false;
  let startX = 0;
  let startY = 0;
  let startOrder = tileCfg.order;

  const canvas = document.getElementById("canvas");

  function onPointerDown(e) {
    if (!editMode) return;
    if (e.target !== dragHandle) return;
    e.preventDefault();
    dragging = true;
    startX = e.clientX;
    startY = e.clientY;
    tileEl.style.zIndex = 10;
    tileEl.style.transition = "none";

    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);
  }

  function onPointerMove(e) {
    if (!dragging) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;
    tileEl.style.transform = `translate(${dx}px, ${dy}px)`;
  }

  function onPointerUp(e) {
    if (!dragging) return;
    dragging = false;
    tileEl.style.zIndex = "";
    tileEl.style.transition = "";

    const rect = tileEl.getBoundingClientRect();
    const cx = rect.left + rect.width / 2;
    const cy = rect.top + rect.height / 2;

    let closest = null;
    let closestDist = Infinity;
    const tilesDom = Array.from(canvas.querySelectorAll(".tile"));
    tilesDom.forEach(domTile => {
      if (domTile === tileEl) return;
      const r = domTile.getBoundingClientRect();
      const tx = r.left + r.width / 2;
      const ty = r.top + r.height / 2;
      const d = (tx - cx) ** 2 + (ty - cy) ** 2;
      if (d < closestDist) {
        closestDist = d;
        closest = domTile;
      }
    });

    tileEl.style.transform = "";
    if (closest) {
      const otherId = closest.dataset.id;
      const otherCfg = getTile(otherId);
      const myOrder = tileCfg.order;
      tileCfg.order = otherCfg.order;
      otherCfg.order = myOrder;
      saveState();
      renderAllTiles();
    }

    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("pointerup", onPointerUp);
  }

  dragHandle.addEventListener("pointerdown", onPointerDown);
}

/* Resize (grid-span based) */
function setupTileResize(tileEl, resizeHandle, tileCfg) {
  let resizing = false;
  let startX = 0;
  let startY = 0;
  let startColSpan = tileCfg.colSpan;
  let startRowSpan = tileCfg.rowSpan;

  function onPointerDown(e) {
    if (!editMode) return;
    e.preventDefault();
    resizing = true;
    startX = e.clientX;
    startY = e.clientY;
    startColSpan = tileCfg.colSpan;
    startRowSpan = tileCfg.rowSpan;
    tileEl.style.transition = "none";

    window.addEventListener("pointermove", onPointerMove);
    window.addEventListener("pointerup", onPointerUp);
  }

  function onPointerMove(e) {
    if (!resizing) return;
    const dx = e.clientX - startX;
    const dy = e.clientY - startY;

    const canvas = document.getElementById("canvas");
    const canvasWidth = canvas.clientWidth;
    const colCount = getComputedStyle(canvas)
      .gridTemplateColumns.split(" ").length;
    const colWidth = (canvasWidth - (colCount - 1) * 10) / colCount;
    const rowHeight = parseFloat(getComputedStyle(canvas).gridAutoRows);

    let newColSpan = Math.max(1, Math.round(startColSpan + dx / colWidth));
    let newRowSpan = Math.max(1, Math.round(startRowSpan + dy / rowHeight));

    newColSpan = Math.min(Math.max(1, newColSpan), colCount);
    newRowSpan = Math.min(Math.max(1, newRowSpan), 4);

    tileCfg.colSpan = newColSpan;
    tileCfg.rowSpan = newRowSpan;
    tileEl.style.gridColumn = "span " + newColSpan;
    tileEl.style.gridRow = "span " + newRowSpan;
  }

  function onPointerUp() {
    if (!resizing) return;
    resizing = false;
    tileEl.style.transition = "";
    saveState();
    window.removeEventListener("pointermove", onPointerMove);
    window.removeEventListener("pointerup", onPointerUp);
  }

  resizeHandle.addEventListener("pointerdown", onPointerDown);
}

/* ========= INIT ========= */
state = loadState();
renderAllTiles();
updateClock();
ensureLocationAndWeather();
setInterval(() => {
  ensureLocationAndWeather();
}, 1000 * 60 * 5);
</script>

</body>
</html>
